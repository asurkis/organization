\section{Лекция 1. RMQ \& LCA}
\subsection{RMQ}
Range Minimal Query.

Ввод:
массив $a_1,\ldots,a_n$,
числа $l, r$.

Результат одного запроса --- $\min\{a_l,\ldots,a_r\}$.

\begin{definition}
    Задача с запросами решается за $(f(n), g(n))$,
    если $f(n)$ --- предобработка
    и $g(n)$ --- время запроса.
\end{definition}

\begin{definition}
    Динамический RMQ ---
    со вторым типом запросов
    со вводом $i, x$:
    $a_i \gets x$.
\end{definition}

Решаем динамический RMQ за $(\O(n), \O(\log n))$.

\begin{theorem}
    Не существует решения динамической RMQ за $(\O(n), \o(\log n))$.
\end{theorem}
\begin{proof}
    Пусть это не так.
    Тогда существует алгоритм сортировки:
    \begin{algorithmic}
        \For{$i = 1,\ldots,n$}
            \State $j \gets \arg\min_i\{a_i\}$
            \State $b_i \gets a_j$
            \State $a_j \gets +\infty$
        \EndFor
    \end{algorithmic}
    Тогда мы построили $b_i$ --- отсортированный $a_i$
    за $n \cdot o(\log n) = o(n \log n)$,
    что невозможно.
\end{proof}

\begin{definition}[Дерево отрезков]
    На отрезке длины $n$ --- подотрезки длины $\floor{n/2}$ и $\ceil{n/2}$.
    Дерево полное, но не обязательно сбалансированное.
    Отрезок длины 1 --- лист.
    Высота дерева --- $\ceil{\log n}$.
\end{definition}

%Например, для $n = 10$:
%\begin{center}
%    \begin{tikzpicture}
%        \draw (0,0) rectangle (10,1);
%        \draw (0,1) rectangle (5,2);
%        \draw (5,1) rectangle (10,2);
%        \draw (0,2) rectangle (2,3);
%        \draw (0,3) rectangle (1,4);
%        \draw (1,3) rectangle (2,4);
%        \draw (2,2) rectangle (5,3);
%        \draw (2,3) rectangle (5,4);
%        \draw (2,3) rectangle (5,4);
%        \draw (5,2) rectangle (10,3);
%    \end{tikzpicture}
%\end{center}

\begin{definition}
    Отрезок $S(v)$, соответствующий вершине $v$ в этом дереве --- \emph{канонический}.
\end{definition}

\begin{statement}
    Любой отрезок разбивается на не более чем $2 \cdot \ceil{\log n}$ канонических.
\end{statement}

\begin{proof}
    Заведём функцию $split(v, [l, r])$, разбивающую
    отрезок $[l, r]$ в вершине $v$.
    $S(v) = [a, b]$.

    Есть варианты:
    \begin{enumerate}
        \item Отрезок целиком в левом или правом поддереве, т.е.
        либо $r < \floor{(a + b) / 2}$,
        либо $l > \floor{(a + b) / 2}$.
        Тогда всего канонических отрезков не больше, чем во втором случае.

        \item Отрезок не принадлежит ни одному поддереву, $l < \floor{(a + b) / 2} < r$.
        Тогда разбиваем отрезок на два, при каждом следующем спуске
        на левом подотрезке правая граница будет совпадать с правой границей канонического,
        а при спуске по правому --- левая граница совпадает с левой границей канонического.

        Тогда всего отрезков получится не больше, чем $2 \cdot (\text{высота поддерева} + 1) \le 2 \cdot \ceil{\log n}$.
    \end{enumerate}

    В какой-то момент касание точно будет, хотя бы на листьях.
    Всего веток рекурсии не больше 2.
\end{proof}

Решение статической RMQ:
\begin{enumerate}
    \item Строим дерево отрезков с записью минимума на каноническом отрезке.
    $\O(n)$ вершин и $\O(1)$ действий на каждую
    \item На каждый запрос --- разбиваем отрезок на $\O(\log n)$ канонических и ищем минимум.
\end{enumerate}

Тогда всё решение работает за $(\O(n), \O(\log n))$.

Для динамической RMQ на запрос по обновлению элемента
--- обновляем все канонические отрезки, которым он принадлежит.
$\O(\log n)$.

В принципе RMQ работает с любыми \emph{ассоциативными} операциями.

\subsection{Статический RMQ}
RSQ --- Range Sum Query.
Статический решается предподсчётом кумулятивных сумм, $(\O(n), \O(1))$.
Меньше --- невозможно, нужно пройти хотя бы раз по всем элементам.

RMQ можно решить за $(\O(n^2), \O(1))$ --- полным предподсчётом.

Sparce Table, разреженная таблица: $(\O(n \log n), \O(1))$.
Дополнительная информация элемента --- минимум на расстоянии 1, 2, 4, 8, ...
Обход в порядке возрастания расстояния:
\begin{algorithmic}
    \State $t[*, *] \gets +\infty$
    \For{$i = 1,\ldots,n$}
        \State $t[i, 0] \gets i$
    \EndFor
    \For{$k = 0,\ldots,\ceil{\log_2 n - 1}$}
        \For{$i = 1,\ldots,n$}
            \State $t[i, k + 1] \gets \min\{t[i, k]; t[i + 2^k, k]\}$
        \EndFor
    \EndFor
\end{algorithmic}
После этого для отрезка $[l, r]$ берём $k = \floor{\log_2(r - l)}$,
и ответ --- $\min\{t[l, k]; t[r - 2^k; k]\}$ (т.е. из двух покрывающих отрезков).

\subsection{LCA}
Least Common Ancestor.

Ввод:
произвольное корневое (т.е. у вершины --- указатель на родителя) дерево,
две вершины $u$ и $v$.

Результат:
наименьший общий предок $u$ и $v$.

Выпишем для каждой вершины указатель на её предка на расстоянии 1, 2, 4, 8, ...
Обход в порядке возрастания расстояния.
Также выпишем глубину вершины.

Пусть $u$ --- более глубокая.
Тогда перейдём к тому её предку, чтобы совпала глубина с $v$.

Затем можно ,,двоичным поиском`` найти общего предка $u$ и $v$:
если запрос на расстояние даёт общего предка,
то уменьшаем длину запроса,
иначе стоит перейти к необщим предкам и продолжать запросы.

Тогда весь алгоритм работает за $(\O(n \log h), \O(\log h))$,
где $h = \O(n)$ --- высота дерева.

\subsection{LCA через RMQ}
Выпишем дерево Эйлерова обхода:
DFS от корня, на каждой вершине
(в т.ч. при возврате, т.е. несколько раз)
записываем её ($a_i$) и её глубину ($b_i$).

Затем ищем первое вхождение $u$ --- $\text{first}(u)$,
первое вхождение $v$ --- $\text{first}(v)$
(пусть $v$ --- та, в которую входим позже),
и вершину минимальной глубины на этом отрезке.

\begin{statement}
    $w = \text{LCA}(u, v)$.
    $b(w) = \text{RMQ}(d, [\text{first}(u), \text{first}(v)])$.
\end{statement}
\begin{proof}
    В дереве единственный путь между вершинами --- через их общего предка,
    поэтому $w$ будет присутствовать на отрезке $[\text{first}(u), \text{first}(v)]$.
    Если бы существовала вершина меньшей глубины, то был бы предок $w$,
    что противоречит обхооду DFS.
\end{proof}

\begin{definition}[Сведение]
    $(f(n), g(n))$ --- сведение задачи $A$ к задаче $B$, если возможны приведения:
    \begin{itemize}
        \item $\text{инстанс}~A \to \text{инстанс}~B$ за $f(n)$
        \item $\text{запрос}~A \to \text{запрос}~B$ за $g(n)$
        \item $\text{ответ}~B \to \text{ответ}~A$ за $g(n)$
    \end{itemize}
\end{definition}

Тогда полученное сведение LCA к RMQ --- $(\O(n), \O(1))$,
тогда умеем решать LCA за $(\O(n \log n), \O(1))$.

Существует обратное сведение RMQ к LCA за $(\O(n), \O(1))$
через построение кучи (не двоичной)
и поиск поиск LCA от концов отрезка.

Метод Фарако-Колтона, Бендера позволяет решать RMQ
за два сведения, и $(\O(n), \O(1))$.
