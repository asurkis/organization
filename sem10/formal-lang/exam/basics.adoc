== Основы
1. Алфавит, язык, способы задания языка.
2. Система переписывания строк (машина Маркова).
3. Теоретико-множественные операции над языками.
4. Задача поиска путей с ограничениями в виде формальных языков.

=== Алфавит, язык, способы задания языка

##Алфавит## -- некоторое конечное множество.
Элемент алфавита называют ##символом##.
Традиционно алфавит обозначается как stem:[Sigma].

##Слово## / ##строка## -- последовательность (возможно, пустая) элементов алфавита.
##Конкатенацию## слов stem:[A] и stem:[B] записывают как stem:[A * B] или stem:[A B].
Множество всех слов над алфавитом stem:[Sigma] обозначается как stem:[Sigma^{**}].

##Язык## -- множество слов над алфавитом.
Любой язык stem:[bbb L] над алфавитом stem:[Sigma] -- подмножество stem:[Sigma^{**}]

Способы задания языка:

* ##Перечисление всех слов## (для конечных языков)
* ##Распознаватель## -- алгоритм, принимающий на вход слово, и отвечающий, принадлежит ли оно языку
* ##Генератор## -- алгоритм, выдающий последовательно все слова языка

=== Система переписывания строк (машина Маркова)

Задаётся алфавит и набор правил вида
stem:[L -> R] и stem:[L -> * R], где stem:[L] и stem:[R]
-- некоторые слова над алфавитом, а stem:[->] и stem:[*] отсутствуют в алфавите.
На вход подаётся некоторое слово stem:[W].
На каждом шаге:

. Текущее слово -- stem:[W]
.. Если есть правило stem:[L -> R] или stem:[L -> * R] такое, что stem:[W = A L B],
   то новое слово -- stem:[W' = A R B].
   Если это было правило вида stem:[L -> * R], то выполнение завершается
.. Если подходящего правила нет, то выполнение завершается
. Если выполнение не завершилось, перейти к шагу 1

В ##нормальном алгоритме Маркова## правила имеют приоритет в порядке их определения,
а из всех возможных подстановок stem:[W = A L B] выбирается та, в которой stem:[|A| = min].

Недетерминированная машина Маркова позволяет задать генератор языка.
Если в алфавите выделить подмножество ##нетерминалов##
и добавить ограничения:

* Запрещены правила stem:[L -> * R]
* Левая часть правила должна содержать хотя бы один нетерминал
* Выполнение не может остановиться, если текущее слово содержит нетерминал

То тогда недетерминированная машина Маркова станет ##формальной грамматикой##:
stem:[G = (: Sigma; N; P; S :)], где
stem:[G] -- формальная грамматика,
stem:[Sigma] -- множество терминалов,
stem:[N] -- множество нетерминалов,
stem:[P] -- множество правил, а
stem:[S] -- ##стартовый нетерминал##.

=== Теоретико-множественные операции над языками.

* Объединение stem:[bbb K uu bbb L]
* Пересечение stem:[bbb K nn bbb L]
* Разность stem:[bbb K \\ bbb L]
* Дополнение stem:[bar bbb K = Sigma^** \\ bbb K]
* Конкатенация (произведение) stem:[bbb K * bbb L = { v * w | v in bbb K, w in bbb L }]
* Степень

[stem]
++++
{:
    [ bbb L^0 = { epsilon } ],
    [ bbb L^(k + 1) = L^k * L ]
:}
++++

* Итерация stem:[bbb L^** = uuu_(k >= 0) bbb L^k]
* Позитивная итерация stem:[bbb L^+ = uuu_(k > 0) bbb L^k]

Приоритеты:

. Итерация
. Умножение
. Все остальные операции

=== Задача поиска путей с ограничениями в виде формальных языков.
