= Билеты по алгоритмам
:language: Russian
:toc:
:source-highlighter: rouge
:source-language: julia
:stem: asciimath

== Теормин

Алгоритм. Память и время как ресурсы. Вычисление чисел Фибоначчи:
экспоненциальный рекурсивный алгоритм, полиномиальный алгоритм.
O-символика как инструмент оценки ресурсов,
различные асимптотики (логарифм, полином, экспонента).
Все алгоритмы курса: оценки сложности и решаемые ими задачи.

=== Числа Фибоначчи

.Экспоненциальный алгоритм:
[source]
----
function fib(n)
    if n < 2
        n
    else
        fib(n - 1) + fib(n - 2)
    end
end
----

.Полиномиальный (линейный) алгоритм:
[source]
----
function fib(n)
   a = 0
   b = 1
   for i=1:n
       c = a + b
       a = b
       b = c
   end
   a
end
----

.Логарифмический алгоритм:
[source]
----
# Возведение матрицы в степень
using LinearAlgebra function fib(n)
   function helper(mat, pow)
       if pow <= 1
           mat
       else
           tmp = helper(mat, pow ÷ 2)
           tmp *= tmp
           if pow % 2 == 1
               tmp *= mat
           end
           tmp
       end
   end
   (helper([0 1; 1 1], n) * [0; 1])[1]
end
----

=== O-нотация

[stem]
++++
f in O(g) <=> exists C > 0, N | forall n >= N : f(n) < C * g(n)

f in Omega(g) <=> exists C > 0, N | forall n >= N : f(n) > C * g(n)

Theta(g(n)) = O(g) nn Omega(g)

f in o(g) <=> forall C > 0 exists N | forall n >= N : f(n) < C * g(n)

f in omega(g) <=> forall C > 0 exists N | forall n >= N : f(n) > C * g(n)
++++

== 1. Элементарные структуры данных

Массивы переменного размера: аддитивная и мультипликативная схемы реаллокации.
Односвязный список, двусвязный список.
Абстрактные типы данных, интерфейс и реализация.
Стек, очередь, дек; моделирование на основе массива.
Моделирование очереди с помощью двух стеков.
Амортизационный анализ: метод учётных стоимостей операций и метод предоплаты.

=== Массивы переменного размера
- Доступ к любому элементу за stem:[O(1)]
- Вставка в конец
- Удаление с конца

==== Аддитивная схема
Раз в несколько добавлений происходит переаллокация.
Сложность: начинаем с пустого массива,
stem:[k] реаллокаций раз в stem:[m] элементов.
Тогда время работы --
[stem]
++++
mk + sum_(i=0)^(k-1) mi = \
= m sum_(i=1)^k i = \
= m (k (k + 1)) / 2 in \
in O(mk^2) = O(n^2)
++++
Амортизированная сложность -- stem:[O(n)] на одну вставку в конец.

==== Мультипликативная схема
Переаллокация умножает размер массива.
Амортизированная сложность: начинаем с пустого массива,
размер каждый раз умножается на stem:[q], добавляем stem:[floor(q^k)] элементов.
Тогда время работы --
[stem]
++++
floor(q^k) + sum_(i=0)^(k-1) floor(q^i) = \
= sum_(i=0)^k floor(q^i) <= \
<= sum_(i=0)^k q^i = \
= 1 + q * (1 - q^k) / (1 - q) = \
= (q^(k+1) - 1) / (q - 1) in \
in O(q^k) = O(n)
++++
Амортизированная сложность -- stem:[O(1)] на одну вставку в конец.

=== Списки
==== Односвязный
- Доступ к первому элементу за stem:[O(1)]
- Вставка в любую точку за stem:[O(1)]
- Удаление из любой точки за stem:[O(1)]

==== Двусвязный
- Односвязный список + указатель назад
- Соединение за stem:[O(1)]

=== Абстрактные типы данных
==== Интерфейс
- Список допустимых операций
- Инварианты

==== Реализация
- Конкретные алгоритмы

==== Стек
- Вставка в начало
- Удаление из начала

==== Очередь
- Вставка в конец
- Удаление из начала

==== Дек
- Стек + очередь

=== Дек на массиве
- Массив переменного размера
- Номер начала
- Количество элементов
- Вставка -- если хватает места, то циклическое смещение итератора (при вставке в начало)
  и установка значения, затем смена количества элементов.
  Если места не хватает -- переаллокация массива.
- Удаление -- выбор значения либо по итератору, либо по циклическому смещению,
  затем смена количества элементов.
- Дек является и списком, и очередью

[source]
----
mutable struct Deque{T}
    arr :: Vector{T}
    first :: Int64
    size :: Int64
    Deque{T}() where T = new(Vector{T}(undef, 1), 1, 0)
end

function ensure_capacity!(deque :: Deque{T}, capacity :: Int64) where T
    length(deque.arr) < capacity || return
    new_arr = Vector{T}(undef, 2 * length(deque.arr))
    for i=1:deque.size
        new_arr[i] = deque.arr[(deque.first + i - 2) % length(deque.arr) + 1]
    end
    deque.arr = new_arr
    deque.first = 1
end

function push_back!(deque :: Deque{T}, x :: T) where T
    ensure_capacity!(deque, deque.size + 1)
    deque.arr[(deque.first + deque.size - 1) % length(deque.arr) + 1] = x
    deque.size += 1
end

function push_front!(deque :: Deque{T}, x :: T) where T
    ensure_capacity!(deque, deque.size + 1)
    deque.first = (deque.first + length(deque.arr) - 2) % length(deque.arr) + 1
    deque.arr[deque.first] = x
    deque.size += 1
end

function pop_back!(deque :: Deque{T}) where T
    deque.size -= 1
    deque.arr[(deque.first + deque.size - 1) % length(deque.arr) + 1]
end

function pop_front!(deque :: Deque{T}) where T
    x = deque.arr[deque.first]
    deque.first = deque.first % length(deque.arr) + 1
    deque.size -= 1
    x
end
----

=== Очередь на двух стеках
[source]
----
mutable struct Queue{T}
    left :: Deque{T}
    right :: Deque{T}
    Queue{T}() where T = new(Deque{T}(), Deque{T}())
end

function queue_push!(q :: Queue{T}, x :: T) where T
    push_back!(q.right, x)
end

function queue_pop!(q :: Queue{T}) where T
    if q.left.size == 0
        while q.right.size != 0
            push_back!(q.left, pop_back!(q.right))
        end
    end
    pop_back!(q.left)
end
----

=== Амортизационный анализ
Средняя стоимость операции за большое количество действий.

Пример: стек с операцией stem:["multipop"(n)]
-- для удаления stem:[n] элементов за stem:[O(n)] сначала их нужно добавить,
чему предшествуют stem:[n] операций stem:["push"(x)] за stem:[O(1)].
Всего -- stem:[n + 1] операция, поэтому амортизированная стоимость
-- stem:[(2n) / (n + 1) = O(1)].

Например, двоичный счётчик, где изменение 1 бита -- stem:[O(1)].
Тогда stem:[i]-й бит изменится stem:[n * 2^{-i}] раз,
всего на stem:[n] действий -- stem:[<= 2n = O(n)] времени,
следовательно, на одно действие -- stem:[O(1)] времени в среднем.

==== Метод потенциалов
Заведём stem:[Phi] -- потенциал.
После выполнения stem:[i] действий потенциал -- stem:[Phi_i].
Обозначим _стоимость_ операции stem:[alpha_i = t_i + Phi_i - Phi_{i - 1}].
Тогда если
[stem]
++++
{{:
[forall i : alpha_i in O(f(n, m))],
[forall i : Phi_i in O(n * f(n, m))]
:}:}
++++
то средняя амортизационная стоимость stem:[t in O(f(n, m))].

Доказательство:
[stem]
++++
a = 1/n sum_(i=1)^n t_i = \
= 1/n sum_(i=1)^n (alpha_i - Phi_i + Phi_{i - 1}) = \
= 1/n (sum_(i=1)^n alpha_i - sum_(i=1)^n Phi_i + sum_(i=1)^n Phi_{i - 1}) = \
= 1/n (sum_(i=1)^n alpha_i - sum_(i=1)^n Phi_i + sum_(i=0)^(n-1) Phi_i) = \
= 1/n (sum_(i=1)^n alpha_i - Phi_N + Phi_0) = \
= 1/n (sum_(i=1)^n O(f(n, m)) - O(n * f(n, m)) + O(n * f(n, m))) = \
= O(f, n)
++++

Пример: стек с stem:["multipop"(n)]:
- Потенциал -- количество элементов в стеке stem:[n in O(n * 1)]
- stem:[alpha("push") = 1 + Delta Phi = 2 in O(1)]
- stem:[alpha("pop") = 1 + Delta Phi = 0 in O(1)]
- stem:[alpha("multipop"(n)) = n + Delta Phi = 0 in O(1)]
Следовательно, амортизированная стоимость операций -- stem:[t in O(1)].

==== Метод предоплаты
Заводим учётные стоимости stem:[alpha_i] так, что
stem:[sum_(i=1)^n alpha_i >= sum_(i=1)^n t_i].
Тогда stem:[forall i : alpha_i in O(f) => a in O(f)].

Пример: стек с stem:["multipop"(n)].
Для stem:["push"] будем использовать 2 монеты,
тогда учётную стоимость удалений можно принять равной 0,
используя оставшуюся "лишнюю" монету после вставки.
Тогда stem:[a in O(f)].

== 2. Разделяй и властвуй

Рекуррентные соотношения. Метод «разделяй и властвуй». Умножение
n-битовых чисел: простой рекурсивный алгоритм, улучшенный рекурсивный
алгоритм. Рекуррентные соотношения: основная теорема. Двоичный поиск.

== 3. Сортировка: квадратичные и сортировка слиянием

Квадратичные сортировки. Сортировка слиянием: с рекурсией и без. Нижняя
оценка stem:[Omega(n log n)] для сортировки сравнениями.

== 4. Сортировка кучей

Куча, построение кучи за линейное время. Очередь с приоритетами на
основе кучи. Сортировка с помощью кучи, частичная сортировка. Операции с
d-ичной кучей.

== 5. Быстрая сортировка

Анализ среднего времени работы, анализ глубины рекурсии, элиминация
хвостовой рекурсии, IntroSort, массивы с малым количеством различных
элементов, QuickSort3.

== 6. Линейные сортировки и порядковые статистики

Сортировка подсчётом, стабильность. Цифровая сортировка. Bucket sort для
равномерно распределённых вещественных чисел. Порядковые статистики,
нахождение за линейное в среднем время. Медиана медиан.

== 7. Динамическое программирование 1

Общие принципы динамического программирования. Кратчайшие пути в
ациклических ориентированных графах. Наибольшая возрастающая
подпоследовательность: подзадачи, порядок на подзадачах, граф подзадач,
сравнение с рекурсивным алгоритмом; нахождение не только длины, но и
самой подпоследовательности. Дискретная задача о рюкзаке.

== 8. Динамическое программирование 2

Умножение матриц. Независимые множества максимального веса в деревьях.
Редакционное расстояние: граф на подзадачах, нахождение кратчайшего пути
в данном графе; вычисление редакционного расстояния с использованием
линейной памяти (алгоритм Хиршберга).

== 9. Жадные алгоритмы 1

Покрытие точек единичными отрезками. Непрерывный рюкзак. Задача о выборе
заявок. Максимальные независимые множества в деревьях. Код Хаффмана.

== 10. Жадные алгоритмы 2

Минимальное покрывающее дерево: свойство разреза, жадная стратегия,
алгоритм Прима, алгоритм Краскала.

== 11. Система непересекающихся множеств

Представление множеств с помощью деревьев, эвристики: ранги и сжатие
путей, верхняя оценка stem:[O(m log^** n)] на время работы m операций.
Анализ учётных стоимостей операций: метод ростовщика.

== 12. Декомпозиция графов 1

Графы и способы их представления: матрица смежности, списки смежности,
матрица инцидентности. Поиск в глубину. Графы и способы их
представления, способы использования графов. Поиск в глубину в
неориентированных графах, выделение компонент связности, нахождение
циклов. Поиск в глубину в ориентированных графах: поиск цикла.

== 13. Декомпозиция графов 2

Поиск в глубину в ориентированных графах: топологическая сортировка
вершин, выделение компонент сильной связности в орграфах.

== 14. Кратчайшие пути в графах

Нахождение кратчайших путей из одной вершины в невзвешенных графах,
поиск в ширину. Нахождение кратчайших путей из одной вершины в графах с
положительными весами, алгоритм Дейкстры, оценка времени работы при
различных реализациях очереди с приоритетами (массивом, двоичной кучей,
d-ичной кучей).

== 15. Кратчайшие пути в графах с отрицательными рёбрами

Алгоритм Беллмана-Форда, проверка наличия цикла отрицательного веса.
Кратчайшие пути в ациклических ориентированных графах. Кратчайшие пути
между всеми парами вершин: алгоритм Флойда-Уоршелла.

== Примечания

Билет состоит из двух вопросов. При подготовке билетов пользоваться
любыми источниками запрещается. Билеты рассказываются устно. Кроме
материала билета нужно уметь отвечать и на вопросы по другим билетам.
После ответа выдаётся задача. Перед получением билета студенту
предлагается написать тест. Оценка за тест -- это максимальная оценка,
которую студент может получить за экзамен.
